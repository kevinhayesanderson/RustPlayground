Rust:
  - An Associated function is a function that's implemented on a type.
  - Enumeration, often called an enum, which is a type that can be in one of multiple states:
      - Each possible state is called a variant.
  - Ensuring Reproducible Builds with the Cargo.lock File:
      - it’s often checked into source control with the rest of the code in your project.
  - Shadowing lets us reuse the variable name rather than forcing us to create two unique variables:
  - On Windows, pressing enter results in a carriage return and a newline, \r\n:
      - The trim method eliminates \n or \r\n
Datatypes:
  two data type subsets:
    - scalar
    - compound
  Rust is a statically typed language:
    - which means that it must know the types of all variables at compile time
Scalar Types:
  A scalar type represents a single value:
  Rust has four primary scalar types:
    - integers:
        - Rust’s defaults are generally good places to start: integer types default to i32.
        - The primary situation in which you'd use isize or usize is when indexing some sort of collection.
        - https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow
    - floating-point numbers:
        - Rust’s floating-point types are f32 and f64
        - The binary format of a 32-bit single-precision float variable is s-eeeeeeee-fffffffffffffffffffffff, where s=sign, e=exponent, and f=fractional part (mantissa).
          - A single-precision float only has about 7 decimal digits of precision (actually the log base 10 of 223, or about 6.92 digits of precision).
          - The greater the integer part is, the less space is left for floating part precision.
        - https://www.geeksforgeeks.org/difference-between-single-precision-and-double-precision/
    - Booleans
    - characters:
        - Rust’s char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.
          - Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust.
          - Unicode Scalar Values range from U+0000 to U+D7FF and U+E000 to U+10FFFF inclusive.
Compound types:
  - Compound types can group multiple values into one type.
  - Rust has two primitive compound types:
      - tuples:
          - The tuple without any values has a special name, unit.
          - This value and its corresponding type are both written () and represent an empty value or an empty return type.
          - Expressions implicitly return the unit value if they don’t return any other value.
      - arrays:
Functions:
  Rust code uses snake case as the conventional style for function and variable names, in which all letters are lowercase and underscores separate words:
    - parameter and argument interchangeably for either the variables in a function’s definition or the concrete values passed in when you call a function.
  Statements are instructions that perform some action and do not return a value:
  Expressions evaluate to a resultant value. Let’s look at some examples:
    - Calling a function is an expression.
    - Calling a macro is an expression.
    - A new scope block created with curly brackets is an expression.
    - Expressions do not include ending semicolons.
      - If you add a semicolon to the end of an expression, you turn it into a statement, and it will then not return a value.
Control Flow:
  - if expressions
  - Rust has three kinds of loops:
      - loop:
          - The loop keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.
          - Loop Labels to Disambiguate Between Multiple loops:
              - You can optionally specify a loop label on a loop that you can then use with break or continue to specify that those keywords apply to the labeled loop instead of the innermost loop.
              - Loop labels must begin with a single quote.
      - while:
      - for:
Ownership:
  It enables Rust to make memory safety guarantees without needing a garbage collector:
    - related features: borrowing, slices, and how Rust lays data out in memory
  The main purpose of ownership is to manage heap data:
  Ownership Rules:
    - Each value in Rust has an owner.
    - There can only be one owner at a time.
    - When the owner goes out of scope, the value will be dropped.
  Memory and Allocation:
    When a variable goes out of scope, Rust calls a special function for us:
    This function is called drop, and it’s where the author of String can put the code to return the memory:
    Rust calls drop automatically at the closing curly bracket:
  Data pointers pointing to the same location:
    This is a problem:
      when s2 and s1 go out of scope, they will both try to free the same memory.
      This is known as a double free error and is one of the memory safety bugs we mentioned previously.
      Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.
    The concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy:
    But because Rust also invalidates the first variable, instead of being called a shallow copy, it’s known as a move:
    Rust will never automatically create “deep” copies of your Datatypes:
    Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance:
  Variables and Data Interacting with Clone: If we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called clone.
  Stack-Only Data: Copy
    Rust has a special annotation called the Copy trait that we can place on types that are stored on the stack
    Rust won’t let us annotate a type with Copy if the type, or any of its parts, has implemented the Drop trait.
  Types that implement Copy:
    - All the integer types, such as u32.
    - The Boolean type, bool, with values true and false.
    - All the floating-point types, such as f64.
    - The character type, char.
    - Tuples, if they only contain types that also implement Copy. For example, (i32, i32) implements Copy, but (i32, String) does not.
  Ownership and Functions: Passing a variable to a function will move or copy, just as assignment does.
  Return Values and Scope: When a variable that includes data on the heap goes out of scope, the value will be cleaned up by drop unless ownership of the data has been moved to another variable.
  References and Borrowing:
    Rust has a feature for using a value without transferring ownership, called references:
